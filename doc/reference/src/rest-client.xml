<?xml version="1.0" encoding="UTF-8"?>
<chapter id="rest-client">
  <title>Accessing RESTful services on the Client</title>

  <para>
	Simplifies communication with HTTP servers, and enforces RESTful principles. 
	It handles HTTP connections, leaving application code to provide URLs (with possible template variables) 
	and extract results.
  </para>
   
   <para>The <classname>RestTemplate</classname> is the core class for
   client-side access to RESTful services. It is conceptually similar to
   other template classes in Spring, such as
   <classname>JdbcTemplate</classname> and <classname>JmsTemplate</classname>
   and other template classes found in other Spring portfolio projects.
   <classname>RestTemplate</classname>'s behavior is customized by providing
   callback methods and configuring the
   <interfacename>HttpMessageConverter</interfacename> used to marshal
   objects into the HTTP request body and to unmarshal any response back
   into an object. As it is common to use XML as a message format, Spring
   provides a <classname>MarshallingHttpMessageConverter</classname> that
   uses the Object-to-XML framework that is part of the
   <classname>org.springframework.oxm</classname> package. This gives you a
   wide range of choices of XML to Object mapping technologies to choose
   from.</para>
 
   <para>This section describes how to use the
   <classname>RestTemplate</classname> and its associated
   <interfacename>HttpMessageConverters</interfacename>.</para>
 
   <section id="rest-resttemplate">
     <title>RestTemplate</title>
 
     <para>Invoking RESTful services in Java is typically done using a helper
     class such as Jakarta Commons <classname>HttpClient</classname>. For
     common REST operations this approach is too low level as shown
     below.</para>
 
     <programlisting>String uri = "http://example.com/hotels/1/bookings";
 
PostMethod post = new PostMethod(uri);
String request = // create booking request content
post.setRequestEntity(new StringRequestEntity(request));
 
httpClient.executeMethod(post);
 
if (HttpStatus.SC_CREATED == post.getStatusCode()) {
 Header location = post.getRequestHeader("Location");
 if (location != null) {
   System.out.println("Created new booking at :" + location.getValue());
 }
}</programlisting>
 
     <para>RestTemplate provides higher level methods that correspond to each
     of the six main HTTP methods that make invoking many RESTful services a
     one-liner and enforce REST best practices.</para>
 
     <table>
       <title>Overview of RestTemplate methods</title>
 
       <tgroup cols="2">
         <tbody>
           <row>
             <entry><emphasis role="bold">HTTP Method</emphasis></entry>
 
             <entry><emphasis role="bold">RestTemplate
             Method</emphasis></entry>
           </row>
 
           <row>
             <entry>DELETE</entry>
 
             <entry><ulink
              url="http://static.springsource.org/spring/docs/3.0.x/javadoc-api/org/springframework/web/client/RestTemplate.html#delete(String,%20Object...)">delete</ulink></entry>
           </row>
 
           <row>
             <entry>GET</entry>
 
             <entry><ulink
              url="http://static.springsource.org/spring/docs/3.0.x/javadoc-api/org/springframework/web/client/RestTemplate.html#getForObject(String,%20Class,%20Object...)">getForObject</ulink></entry>
           </row>
 
           <row>
             <entry></entry>
 
             <entry><ulink
              url="http://static.springsource.org/spring/docs/3.0.x/javadoc-api/org/springframework/web/client/RestTemplate.html#getForEntity(String,%20Class,%20Object...)">getForEntity</ulink></entry>
           </row>
 
           <row>
             <entry>HEAD</entry>
 
             <entry><ulink
              url="http://static.springsource.org/spring/docs/3.0.x/javadoc-api/org/springframework/web/client/RestTemplate.html#headForHeaders(String,%20Object...)">headForHeaders(String
             url, String… urlVariables)</ulink></entry>
           </row>
 
           <row>
             <entry>OPTIONS</entry>
 
             <entry><ulink
              url="http://static.springsource.org/spring/docs/3.0.x/javadoc-api/org/springframework/web/client/RestTemplate.html#optionsForAllow(String,%20Object...)">optionsForAllow(String
             url, String… urlVariables)</ulink></entry>
           </row>
 
           <row>
             <entry>POST</entry>
 
             <entry><ulink
              url="http://static.springsource.org/spring/docs/3.0.x/javadoc-api/org/springframework/web/client/RestTemplate.html#postForLocation(String,%20Object,%20Object...)">postForLocation(String
             url, Object request, String… urlVariables)</ulink></entry>
           </row>
 
           <row>
             <entry></entry>
 
             <entry><ulink
              url="http://static.springsource.org/spring/docs/3.0.x/javadoc-api/org/springframework/web/client/RestTemplate.html#postForObject(java.lang.String,%20java.lang.Object,%20java.lang.Class,%20java.lang.String...)">postForObject(String
                                  url, Object request, Class&lt;T&gt; responseType, String…
                                  uriVariables)</ulink></entry>
           </row>
 
           <row>
             <entry>PUT</entry>
 
             <entry><ulink
              url="http://static.springsource.org/spring/docs/3.0.x/javadoc-api/org/springframework/web/client/RestTemplate.html#put(String,%20Object,%20Object...)">put(String
             url, Object request, String…urlVariables)</ulink></entry>
           </row>
         </tbody>
       </tgroup>
     </table>
 
     <para>The names of <classname>RestTemplate</classname> methods follow a
     naming convention, the first part indicates what HTTP method is being
     invoked and the second part indicates what is returned. For example, the
     method <methodname>getForObject()</methodname> will perform a GET, convert
     the HTTP response into an object type of your choice and return that
     object. The method <methodname>postForLocation()</methodname> will do a
     POST, converting the given object into a HTTP request and return the
     response HTTP Location header where the newly created object can be
     found. In case of an exception processing the HTTP request, an exception
     of the type <classname>RestClientException</classname> will be
     thrown; this behavior can be changed by plugging in another <interfacename>ResponseErrorHandler</interfacename>
          implementation into the <classname>RestTemplate</classname>.</para>
 
     <para>Objects passed to and returned from these methods are converted to
     and from HTTP messages by
     <interfacename>HttpMessageConverter</interfacename> instances.
     Converters for the main mime types are registered by default, but you
     can also write your own converter and register it via the
     <methodname>messageConverters()</methodname> bean property. The default
     converter instances registered with the template are
     <classname>ByteArrayHttpMessageConverter</classname>,
     <classname>StringHttpMessageConverter</classname>,
     <classname>FormHttpMessageConverter</classname> and
     <classname>SourceHttpMessageConverter</classname>. You can override
     these defaults using the <methodname>messageConverters()</methodname> bean
     property as would be required if using the
     <classname>MarshallingHttpMessageConverter</classname> or
     <classname>MappingJacksonHttpMessageConverter</classname>.</para>
 
     <para>Each method takes URI template arguments in two forms, either as a
     <literal>String</literal> variable length argument or a
     <literal>Map&lt;String,String&gt;</literal>. For example,</para>
 
     <programlisting language="java">String result = restTemplate.getForObject("http://example.com/hotels/{hotel}/bookings/{booking}",
                                         String.class,"42", "21");
</programlisting>
 
     <para>using variable length arguments and</para>
 
     <programlisting language="java">Map&lt;String, String&gt; vars = Collections.singletonMap("hotel", "42");
String result =
 restTemplate.getForObject("http://example.com/hotels/{hotel}/rooms/{hotel}", String.class, vars);
</programlisting>
 
     <para>using a <literal>Map&lt;String,String&gt;</literal>.</para>
 
     <para>To create an instance of <classname>RestTemplate</classname> you can
     simply call the default no-arg constructor. This will use standard Java
     classes from the <literal>java.net</literal> package as the underlying
     implementation to create HTTP requests. This can be overridden by
     specifying an implementation of
     <interfacename>ClientHttpRequestFactory</interfacename>. Spring provides
     the implementation
     <classname>CommonsClientHttpRequestFactory</classname> that uses the
     Jakarta Commons <classname>HttpClient</classname> to create requests.
     <classname>CommonsClientHttpRequestFactory</classname> is configured
     using an instance of
     <classname>org.apache.commons.httpclient.HttpClient</classname> which
     can in turn be configured with credentials information or connection
     pooling functionality.</para>
 
     <para>The previous example using Jakarta Commons
     <classname>HttpClient</classname> directly rewritten to use the
     <classname>RestTemplate</classname> is shown below</para>
 
     <programlisting>uri = "http://example.com/hotels/{id}/bookings";
 
RestTemplate template = new RestTemplate();
 
Booking booking = // create booking object
 
URI location = template.postForLocation(uri, booking, "1");
</programlisting>
 
     <para>The general callback interface is
     <interfacename>RequestCallback</interfacename> and is called when the
     execute method is invoked.</para>
 
     <programlisting language="java">public &lt;T&gt; T execute(String url, HttpMethod method, RequestCallback requestCallback,
                    ResponseExtractor&lt;T&gt; responseExtractor,
                    String... urlVariables)
 
 
// also has an overload with urlVariables as a Map&lt;String, String&gt;.</programlisting>
 
     <para>The <interfacename>RequestCallback</interfacename> interface is
     defined as</para>
 
     <programlisting language="java">public interface RequestCallback {
void doWithRequest(ClientHttpRequest request) throws IOException;
}</programlisting>
 
     <para>and allows you to manipulate the request headers and write to the
     request body. When using the execute method you do not have to worry
     about any resource management, the template will always close the
     request and handle any errors. Refer to the API documentation for more
     information on using the execute method and the meaning of its other
     method arguments.</para>
 
     <section>
       <title>Dealing with request and response headers</title>
 
       <para>Besides the methods described above, the <classname>RestTemplate</classname>
       also has the <methodname>exchange()</methodname> method, which can be
       used for arbitrary HTTP method execution based on the <classname>HttpEntity</classname>
       class.</para>
 
       <para>Perhaps most importantly, the <methodname>exchange()</methodname>
       method can be used to add request headers and read response headers.
       For example:</para>
 
       <programlisting language="java">HttpHeaders requestHeaders = new HttpHeaders();
requestHeaders.set("MyRequestHeader", "MyValue");
HttpEntity&lt;?&gt; requestEntity = new HttpEntity(requestHeaders);
 
HttpEntity&lt;String&gt; response = template.exchange("http://example.com/hotels/{hotel}",
 HttpMethod.GET, requestEntity, String.class, "42");
 
String responseHeader = response.getHeaders().getFirst("MyResponseHeader");
String body = response.getBody();</programlisting>
 
       <para>In the above example, we first prepare a request entity that contains the
       <literal>MyRequestHeader</literal> header. We then retrieve the response, and
       read the <literal>MyResponseHeader</literal> and body.</para>
       </section>
   </section>
 
   <section id="rest-message-conversion">
     <title>HTTP Message Conversion</title>
 
     <para>Objects passed to and returned from the methods
     <methodname>getForObject()</methodname>,
     <methodname>postForLocation()</methodname>, and
     <methodname>put()</methodname> are converted to HTTP requests and from
     HTTP responses by <interfacename>HttpMessageConverters</interfacename>.
     The <interfacename>HttpMessageConverter</interfacename> interface is
     shown below to give you a better feel for its functionality</para>
 
     <programlisting language="java">public interface HttpMessageConverter&lt;T&gt; {
 
     // Indicate whether the given class and media type can be read by this converter.
     boolean canRead(Class&lt;?&gt; clazz, MediaType mediaType);
 
     // Indicate whether the given class and media type can be written by this converter.
     boolean canWrite(Class&lt;?&gt; clazz, MediaType mediaType);
 
     // Return the list of MediaType objects supported by this converter.
     List&lt;MediaType&gt; getSupportedMediaTypes();
 
     // Read an object of the given type from the given input message, and returns it.
     T read(Class&lt;T&gt; clazz, HttpInputMessage inputMessage) throws IOException,
                                                                  HttpMessageNotReadableException;
 
     // Write an given object to the given output message.
     void write(T t, HttpOutputMessage outputMessage) throws IOException,
                                                             HttpMessageNotWritableException;
 
   }</programlisting>
 
     <para>Concrete implementations for the main media (mime) types are
     provided in the framework and are registered by default with the
     <classname>RestTemplate</classname> on the client-side and with
     <classname>AnnotationMethodHandlerAdapter</classname> on the
     server-side.</para>
 
     <para>The implementations of
     <classname>HttpMessageConverter</classname>s are described in the
     following sections. For all converters a default media type is used but
     can be overridden by setting the
     <classname>supportedMediaTypes</classname> bean property</para>
 
     <section id="rest-string-converter">
       <title>StringHttpMessageConverter</title>
 
       <para>An <interfacename>HttpMessageConverter</interfacename>
       implementation that can read and write Strings from the HTTP request
       and response. By default, this converter supports all text media types
       (<literal>text/*</literal>), and writes with a
       <literal>Content-Type</literal> of
       <literal>text/plain</literal>.</para>
     </section>
 
     <section id="rest-form-converter">
       <title>FormHttpMessageConverter</title>
 
       <para>An <interfacename>HttpMessageConverter</interfacename>
       implementation that can read and write form data from the HTTP request
       and response. By default, this converter reads and writes the media
       type <literal>application/x-www-form-urlencoded</literal>. Form data
       is read from and written into a <literal>MultiValueMap&lt;String,
       String&gt;</literal>.</para>
     </section>
 
     <section id="rest-byte-converter">
       <title>ByteArrayMessageConverter</title>
 
       <para>An <interfacename>HttpMessageConverter</interfacename>
       implementation that can read and write byte arrays from the HTTP
       request and response. By default, this converter supports all media
       types (<literal>*/*</literal>), and writes with a
       <literal>Content-Type</literal> of
       <literal>application/octet-stream</literal>. This can be overridden by
       setting the <property>supportedMediaTypes</property> property, and
       overriding <literal>getContentType(byte[])</literal>.</para>
     </section>
 
     <section id="rest-marhsalling-converter">
       <title>MarshallingHttpMessageConverter</title>
 
       <para>An <interfacename>HttpMessageConverter</interfacename>
       implementation that can read and write XML using Spring's
       <interfacename>Marshaller</interfacename> and
       <interfacename>Unmarshaller</interfacename> abstractions from the
       <classname>org.springframework.oxm</classname> package. This converter
       requires a <interfacename>Marshaller</interfacename> and
       <interfacename>Unmarshaller</interfacename> before it can be used.
       These can be injected via constructor or bean properties. By default
       this converter supports (<literal>text/xml</literal>) and
       (<literal>application/xml</literal>).</para>
     </section>
     
     <section id="rest-mapping-json-converter">
       <title>MappingJacksonHttpMessageConverter</title>
       
       <para>An <interfacename>HttpMessageConverter</interfacename>
       implementation that can read and write JSON using Jackson's
       <interfacename>ObjectMapper</interfacename>. JSON mapping can be
       customized as needed through the use of Jackson's provided annotations. When
       further control is needed, a custom
       <interfacename>ObjectMapper</interfacename> can be injected through
       the <literal>ObjectMapper</literal> property for cases where custom
       JSON serializers/deserializers need to be provided for specific types.
       By default this converter supports (<literal>application/json</literal>).</para>
     </section>
 
     <section id="rest-source-converter">
       <title>SourceHttpMessageConverter</title>
 
       <para>An <interfacename>HttpMessageConverter</interfacename>
       implementation that can read and write
       <classname>javax.xml.transform.Source</classname> from the HTTP
       request and response. Only <classname>DOMSource</classname>,
       <classname>SAXSource</classname>, and
       <classname>StreamSource</classname> are supported. By default, this
       converter supports (<literal>text/xml</literal>) and
       (<literal>application/xml</literal>).</para>
     </section>
 
     <section id="rest-buffered-image-converter">
       <title>BufferedImageHttpMessageConverter</title>
 
       <para>An <interfacename>HttpMessageConverter</interfacename>
       implementation that can read and write
       <classname>java.awt.image.BufferedImage</classname> from the HTTP
       request and response. This converter reads and writes the media type
       supported by the Java I/O API.</para>
     </section>
   </section>

</chapter>
